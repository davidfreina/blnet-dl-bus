#define DL_MODE 0xA8
#define GET_MODE 0x81
#define GET_LATEST 0xAB
#define RESET_DATA 0xAF
#define WAIT_TIME 0xBA
#define MAX_RETRIES 10

#define INT16_POSITIVE_MASK 0xFFFF
#define SIGN_BIT 0x8000
#define POSITIVE_VALUE_MASK 0x0FFF
#define TYPE_MASK 0x7000
#define TYPE_DIGITAL 0x1000
#define TYPE_TEMP 0x2000
#define TYPE_VOLUME 0x3000
#define TYPE_RAS 0x7000
#define RAS_POSITIVE_MASK 0x01FF
#define INT32_MASK 0xFFFFFFFF
#define INT32_SIGN 0x80000000

#define __SOCK_SIZE__ 16 /* sizeof(struct sockaddr)	*/

struct BLNETConnection
{
    STREAM *pTcpStream;
    int actualSize;
    int errorCount;
};

struct BLNETData
{
    float collector;
    float buffer_bottom;
    float buffer_top;
    float circulation;
    float return_flow;
    float energy;
    float power;
    int digital[9];
    int speed[1];
};
struct in_addr
{
    unsigned int s_addr;
};
struct sockaddr_in
{
    unsigned short sin_family; /* Address family		*/
    unsigned short sin_port;   /* Port number			*/
    struct in_addr sin_addr;   /* Internet address		*/
    /* Pad to size of `struct sockaddr'. */
    unsigned char __pad[__SOCK_SIZE__ - 2 - 2 - sizeof(struct in_addr)];
};

int connect_to_bootloader(struct BLNETConnection *conn)
{
    if (conn->pTcpStream == NULL)
    {
        conn->pTcpStream = stream_create("/dev/tcp/192.168.90.151/40000", 0, 0);
        if (conn->pTcpStream == NULL)
        {
            printf("Could not create stream");
            return -1;
        }
        // else
        //     printf("Successfully connected to BL-NET\n");
    }
    return 0;
}

void disconnect_from_bootloader(struct BLNETConnection *conn)
{
    if (conn->pTcpStream != NULL)
    {
        stream_close(conn->pTcpStream);
        conn->pTcpStream = NULL;
        // printf("Disconnected from BL-NET\n");
    }
}

int get_mode(struct BLNETConnection *conn)
{
    unsigned char cmd[] = {GET_MODE};
    unsigned char response[1];

    return query(conn, cmd, sizeof(cmd), response, sizeof(response));
    // printf("MODE: %x\n", response[0]);
}

int query(struct BLNETConnection *conn, unsigned char *cmd, int cmd_len, unsigned char *response, int resp_len)
{
    int retVal = send_command(conn->pTcpStream, cmd, cmd_len);
    if (retVal != 0)
        return retVal;
    retVal = receive_response(conn->pTcpStream, response, resp_len);
    if (retVal != 0)
        return retVal;
    if (cmd[0] == GET_MODE)
    {
        if (response[0] != DL_MODE)
        {
            printf("Wrong mode received\n");
            return -1;
        }
    }
    if (!checksum(response, resp_len))
    {
        printf("Checksum error\n");
        return -1;
    }
    return 0;
}

int send_command(STREAM *pTcpStream, unsigned char *cmd, int length)
{
    if (stream_write(pTcpStream, cmd, length) != length)
    {
        printf("Send failed\n");
        return -1;
    }
    stream_flush(pTcpStream);
    return 0;
}

int receive_response(STREAM *pTcpStream, unsigned char *buffer, int length)
{
    int received = stream_read(pTcpStream, buffer, length, 10000);
    if (received != length)
    {
        printf("Receive failed\n");
        return -1;
    }
    return 0;
}

int checksum(unsigned char *data, int length)
{
    if (length == 1)
        return 1;
    unsigned int sum = 0;
    for (int i = 0; i < length - 1; i++)
        sum += data[i];
    return (sum % 256) == data[length - 1];
}

int get_latest(struct BLNETConnection *conn, struct BLNETData *data)
{
    unsigned char cmd[] = {GET_LATEST};
    unsigned char response[55];

    for (int i = 0; i < MAX_RETRIES; i++)
    {
        int retVal = query(conn, cmd, sizeof(cmd), response, sizeof(response));
        if (retVal != 0)
            return retVal;
        if (response[0] != WAIT_TIME)
        {
            // printf("Got latest data\n");
            parse_blnet_data(data, response, conn->actualSize);
            return 0;
        }
    }
    printf("Max retries reached\n");
    return -1;
}

// Parse binary data
void parse_blnet_data(struct BLNETData *parsed_data, unsigned char *data, int data_len)
{
    unsigned short *analog = (unsigned short *)malloc(5 * sizeof(unsigned short));
    unsigned short *kwh = (unsigned short *)malloc(sizeof(unsigned short)), *mwh = (unsigned short *)malloc(sizeof(unsigned short));
    unsigned short *power = (unsigned short *)malloc(sizeof(unsigned short));

    memcpy(analog, data + sizeof(unsigned char), 5 * sizeof(unsigned short));
    parsed_data->collector = convert_analog(analog[0]);
    parsed_data->buffer_bottom = convert_analog(analog[1]);
    parsed_data->buffer_top = convert_analog(analog[2]);
    parsed_data->circulation = convert_analog(analog[3]);
    parsed_data->return_flow = convert_analog(analog[4]);

    memcpy(kwh, data + 38, sizeof(unsigned short));
    memcpy(mwh, data + 40, sizeof(unsigned short));
    parsed_data->energy = convert_energy(*mwh, *kwh);

    memcpy(power, data + 36, sizeof(unsigned short));
    parsed_data->power = convert_power(*power);

    free(power);
    free(kwh);
    free(mwh);
    free(analog);
}

// Convert analog sensor data
float convert_analog(short value)
{
    int mask = value & TYPE_MASK;
    if (mask == TYPE_TEMP)
        return calculate_value(value, 0.1, POSITIVE_VALUE_MASK, SIGN_BIT);
    else if (mask == TYPE_VOLUME)
        return calculate_value(value, 4, POSITIVE_VALUE_MASK, SIGN_BIT);
    else if (mask == TYPE_DIGITAL)
    {
        if (value & SIGN_BIT)
            return 1;
        else
            return 0;
    }
    else if (mask == TYPE_RAS)
        return calculate_value(value, 0.1, RAS_POSITIVE_MASK, SIGN_BIT);
    else
        return calculate_value(value, 1, POSITIVE_VALUE_MASK, SIGN_BIT);
}

// Convert energy data
float convert_energy(int mwh, int kwh)
{
    return mwh * 1000 + calculate_value(kwh, 0.1, INT16_POSITIVE_MASK, SIGN_BIT);
}

// Convert power data
float convert_power(unsigned short value)
{
    printf("%d\n", value);
    return calculate_value(value, 1 / 2560.0, INT16_POSITIVE_MASK, SIGN_BIT);
}

// Helper function to calculate the value
float calculate_value(int value, float multiplier, int positive_mask, int signbit)
{
    int result = value & positive_mask;
    if (value & signbit)
        result = -((result ^ positive_mask) + 1);
    return result * multiplier;
}

void reset_data(struct BLNETData *data)
{
    data->buffer_bottom = 0;
    data->buffer_top = 0;
    data->circulation = 0;
    data->collector = 0;
    data->return_flow = 0;
    data->energy = 0;
    data->power = 0;
}

void error_handler(struct BLNETConnection *conn)
{
    conn->errorCount += 1;
    disconnect_from_bootloader(conn);
    sleeps(10);
}

int main()
{
    printf("START UVR61-3 READER");
    struct BLNETConnection conn;
    conn.pTcpStream = NULL;
    conn.actualSize = 55;
    conn.errorCount = 0;

    struct BLNETData data;
    data.buffer_bottom = 0;
    data.buffer_top = 0;
    data.circulation = 0;
    data.collector = 0;
    data.return_flow = 0;
    data.energy = 0;

    int retVal = 0;

    while (1)
    {
        reset_data(&data);

        retVal = connect_to_bootloader(&conn);
        if (retVal != 0)
        {
            error_handler(&conn);
            continue;
        }
        retVal = get_mode(&conn);
        if (retVal != 0)
        {
            error_handler(&conn);
            continue;
        }
        retVal = get_latest(&conn, &data);
        if (retVal != 0)
        {
            error_handler(&conn);
            continue;
        }

        setoutput(0, data.collector);
        setoutput(1, data.buffer_bottom);
        setoutput(2, data.buffer_top);
        setoutput(3, data.circulation);
        setoutput(4, data.return_flow);
        setoutput(5, data.energy);
        setoutput(6, data.power);
        setoutput(7, conn.errorCount);

        disconnect_from_bootloader(&conn);
        sleeps(10);
    }
    return 0;
}

main();